# C# 7.0 本质论

## 继承

- 派生类不能访问基类的私有成员, 除非派生类同时是基类的嵌套类
- 尽量少为基类写扩展方法
- 可以使用 聚合 来解决多继承的问题
- 重写成员会造成“运行时”调用最深的或者说派生得最远的（most derived）实现

### 抽象类

- 抽象类, 在本身不适合实例化, 或者实例没有意义的时候, 可设置抽象类
- 开发具有良好设计的对象层次结构殊为不易。所以在编程抽象类型时，一定要自己实现至少一个（最好多个）从抽象类型派生的具体类型，以检验自己的设计。

## 格式良好类型

**转换操作符**:

- 定义转换操作符在形式上类似于定义其他操作符，只是“operator”成了转换的结果类型。另外，operator要放在表示隐式或显式转换的implicit或explicit关键字后面
- 弱引用(WeakReference), 创建弱引用（Data）之后，可查看弱引用是否为null来检查垃圾回收。但这里的关键是先将弱引用赋给一个强引用（FileStream data=Data），避免在“检查null值”和“访问数据”这两个动作之间，垃圾回收器运行并清除弱引用。强引用明显会阻止垃圾回收器清除对象，所以它必须先被赋值（而不是先检查Target是不是为null）。
- 对象复活, 调用对象的终结方法时，对该对象的引用都已消失。垃圾回收前唯一剩下的步骤就是运行终结代码。但完全可能无意中重新引用一个待终结的对象。这样，被重新引用的对象就不再是不可访问的，所以不能当作垃圾被回收掉。但假如对象的终结方法已经运行，那么除非显式标记为要进行终结（使用GC.ReRegisterFinalize（）方法），否则终结方法不一定会再次运行。

## 异常处理

- 来自C++等语言的非托管异常通常会造成System.Runtime.InteropServices.SEHException类型的异常，它从System.Exception派生

## 杂-临时记录

关于 ref, out, in  

- ref = out + in
- out (我)告诉外面我会修改值, 并且函数内部会进行赋值初始化
- in (我)告诉外面, 我内部不会修改值, 不会改变引用对象